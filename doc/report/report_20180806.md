# Report 2018-08-13

把每周的报告、心得体会等整理到这里

##  创建二叉树


看二叉树相关内容的时候，发现了`递归遍历`，不懂`递归`是什么意思，于是翻了其他的书看了递归的相关内容，并写和分析了`Haboi塔`的问题

接着二叉树相关内容，层序遍历需要用到`队`的知识，前几天只是粗略的看了一下，所以又翻开了其他书详细的看了一遍，并做了一个队的题目

想建立一个完全二叉树，并实现从左到右，从上到下的构建，准备用`指针数组`来保存每个节点的地址，结果出现一直出现`segmentation fault`

百度后，问题是访问了不该访问的内存，可能是使用指针出现了问题

百度的解决方法：
1、定义了指针以后记得初始化，在使用的时候记得判断是否为NULL；
2、在使用数组的时候是否被初始化，数组下标是否越界，数组元素是否存在等；
3、在变量处理的时候变量的格式控制是否合理等；

将指针数组初始化为NULL，还是不行，所以放弃了使用指针数组来储存各节点的地址，改用`vector`来储存各节点的地址

改后还是出现segmentation fault，可能是使用`new函数`造成的问题

原来：
``` 
vector<btNode<T>*> ve;
btNode *q;
q = new btNode<T>;
ve.push_back(q);
```


改：
```
vector<btNode<T>*> ve;
btNode<T> node;
node.data = 1;
ve.push_back(&node);
```
这种出现了  no match for call to 的错误，查百度是由于不匹配的问题，可能不能直接用&node

进一步改：
```
vector<btNode<T>*> ve;
btNode<T> *pNode，node;
pNode = &node;
node.data = 1;
ve.push_back(&node);
```


想用迭代器遍历vector中的数据，但是出现```need ‘typename' before 'std::vector<btNode<T>*>::iterator it = ve.begin();```,不知道是什么问题

改：  ```auto iterator = ve.begin();```
改完之后编译没有问题了，但是运行后还是出现segmentation fault，那么问题应该是在其他地方，推测是父子节点的赋值弄错了

结果发现是下标错了，vector的下标从0开始，而树的下标从1开始

解决问题后发现用其他函数如先序遍历（preOrder)还是会出现segmentation fault。想了会，应该是vector保存的东西只能相应函数里使用，不是在全局变量，
所以把vector写在树的模板类里面后，问题解决了

求父节点的时候，用下列代码又出现了segmentation fault，仔细看了一下，发现最下层的叶子节点是没有左右子节点的，所以```(*it)->lChild->data```不存在，
```
for(auto it = ve.begin()+1;it != ve.end(); it++)
{
    if((*it)->lChild->data == _data || (*it)->rChild->data == _data)
    {
        cout << _data << "的父节点为" << (*it)->data << endl;
    }
} 
```
改成下列代码，先判断有没有子节点，再判断子节点的data值是不是输入的值
```
for(auto it = ve.begin()+1;it != ve.end(); it++)
{
    if((*it)->lChild != 0 && (*it)->lChild->data == _data)
    {
        cout << _data << "的父节点为" << (*it)->data << endl;
    }

    if((*it)->rChild != 0 && (*it)->rChild->data == _data)
    {
        cout << _data << "的父节点为" << (*it)->data << endl;
    }
}
```
### 启发：
* 使用指针的时候要注意空指针，否则很容易出现egmentation fault的情况

* vector可以代替指针数组，且安全


## 创建图

### 构建邻接表
反复出现
```
 error ld returned 1 exit status
```
百度后的含义：函数定义与调用名称不匹配
反复检查后，发现是只声明但没有定义析构函数
```
～Graphic();
```
修改成下列式子，问题解决
```
～Graphic(){}
```

增加边的时候，出现
```
warning: comparison between signed and unsigned integer expressions
```
百度后的含义：两个变量类型不一致

将
```
if(num1 > node.size()-1 || num2 > node.size()-1) return false;
```
查了vector.size()的类型，发现是无符号的整型，改为下列式子，问题解决
```
if(num1+1 > (int)node.size() || num2+1 > (int)node.size()) return false;
```

### 构建邻接矩阵

想用二级指针和二维数组来构建邻接矩阵，结果一直出现错误，改用vector<vector<int>>后解决

### 注意的问题
* 构造函数如果没有参数列表，在实例化的时候不加()，另外析构函数要声明和定义；
* 添加友元时，要注意是否先声明过类模板
* vector的size()函数返回值是无符号的整型，若用vector.size()-1可能会出现错误（无符号整型的计算与整型的不同）
* 使用类模板时尽量不要使用二级指针以及将二维数组作为函数参数，使用vector<vector<int>>可以代替二维数组


## 其他编程问题

### 递归算法中的Hanoi塔问题

题目：假设有三个命名为X,Y,Z的塔座 ，在塔座X上插有n个直径大小不相同，由小到大编号为1 ，2 ，3 ，··· ，n的圆盘，要求将X座上的圆盘移至塔座Z
并按同样的顺序叠排.
圆盘移动必须遵守下列规则：
1：每次只能移动一个圆盘 2：圆盘可以插在任意一个塔座上 3：任何时刻都不能将一个较大的圆盘放在一个较小的圆盘上

请问：最少移动次数是多少？对应的具体步骤是什么？

#### 分析：不管怎么移动，一定有一步是X塔只剩标号为n的圆盘，Y塔上有其他的(n-1)个圆盘，Z塔上没有圆盘（这样才符合1,3规则），
则下一步是将X上的n号圆盘移动到Z塔上。之后是将Y上的(n-1)个圆盘移动到Z上
即如下图：


问题分解：
X上移动n块到Z上 = X上最上面的(n-1)块圆盘移动到Y上；
				X上n号圆盘移动到Z上；
				Y上的(n-1)块圆盘移动到Z上；


重新命名塔
输出塔：要转移圆盘的塔
过渡塔：起过渡作用的塔
接收塔：最终圆盘所在的塔
则同理可得

输出塔上移动（n-1)块到接受塔上 = 输出塔上最上面的(n-2)块圆盘移动到过渡塔上；
							输出塔上(n-1)号圆盘移动到接收塔上；
							过渡塔上的(n-2)块圆盘移动到接收塔上；

依次分解下去直到n=1时
输出塔上移动（n-1)块到接受塔上 = 输出塔上最上面的1块圆盘移动到接收塔上；

设n块需要移动f(n)次
则次数f(n)=f(n-1)+1+f(n-1)=2f(n-1)+1=2(2f(n-2)+1)+1=4f(n-2)+3=...=2^nf(1)-1=2^n-1 (f(1)=1)

### 要注意的地方
* 注意递归函数的结构，本题中有点像二叉树的中序遍历

### 报数（队）
问题描述
  设有n个人站成一排，从左向右的编号为1～n,现在从左往右报数“1,2,1,2...",数到”1“的人站出来，数到"2"的人站到队伍的最右端，反复报数直到n个人出列为止，
并给出他们出列的顺序。

### 注意的问题
× 弄清楚头和尾的关系


### 全排列
问题描述：求1,2,3...n的全排列

前几天刚学递归，看到陈霖在写着题，就写了一下，大概用了两个小时，差不多懂了递归的用法

#### 思路

每一运算的数一次移到最后一位，其他数前移，那么第n次函数里，有n次移动

### 要注意的地方：

* 找到f(n)与f(n-1)的关系，且(n-1)应该写在下个层函数的函数列表里，不能在函数定义里，这一题就错了，导致数字一直对不上
* 本题里面每次运算时，要把数组初始化成输入的数组，因为每次移动后，数组改变了




## 总结与反思

### 总结
  上周学了顺序表，链表，栈，队，树和图的内容，顺带看了递归的相关内容，并做了一些题目

### 反思
* 使用指针的时候要注意空指针，以及数组和链表的边界，否则很容易出现egmentation fault的情况
* vector可以代替指针数组，二级指针和二维数组，而且安全
* 感觉《妙趣横生的算法》这本书前面的基础知识讲的过于简略，而且有一些错误和有些内容也不完整，所以下周会找一些书籍和视频巩固一下基础数据结构的内容

## 下周的计划
* 复习，并重写一遍二叉树
* 学习文件相关内容，算法的基本思想，排序算法和查找算法，并做相关的题目